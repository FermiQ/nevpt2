```markdown
# `inforb.F90` Module Documentation

## Module Name

`info_orbital_space`

## Purpose

This Fortran module is responsible for managing and defining the structure of the orbital space used in a quantum chemistry calculation, particularly for programs like NEVPT2. It handles information such as:

*   The number of orbitals per symmetry.
*   The classification of orbitals into types: frozen, inactive (core), active, and secondary (virtual), and deleted.
*   Offsets for accessing orbitals of a specific symmetry in a global list.
*   Mappings between different orbital orderings (e.g., external program order vs. internal NEVPT2 order).

The module can obtain this information either by reading from HDF5 files (likely generated by a preceding program like MOLCAS/MOTRA) or by interfacing with data structures populated directly by a calling program (e.g., MOLCAS via the `inforb_molcas` structure).

## Dependencies

*   `hdf5_utils`: Used for reading orbital space definitions (like number of orbitals per symmetry, frozen/deleted counts) from HDF5 data files.

## Public Derived Types

---

### `type_inforb`

This derived type is the primary container for detailed orbital space information used throughout the NEVPT2 program. A public module variable `inforb` of this type holds the data.

| Member     | Type                        | Description                                                                                                |
| :--------- | :-------------------------- | :--------------------------------------------------------------------------------------------------------- |
| `nish(:)`  | `INTEGER, ALLOCATABLE`      | Number of inactive (core) orbitals per symmetry.                                                           |
| `nash(:)`  | `INTEGER, ALLOCATABLE`      | Number of active orbitals per symmetry.                                                                    |
| `nssh(:)`  | `INTEGER, ALLOCATABLE`      | Number of secondary (virtual) orbitals per symmetry.                                                       |
| `nosh(:)`  | `INTEGER, ALLOCATABLE`      | Total number of correlated orbitals (nish + nash + nssh) per symmetry.                                       |
| `nfro(:)`  | `INTEGER, ALLOCATABLE`      | Number of frozen (doubly occupied, core, excluded from correlation) orbitals per symmetry.                 |
| `ndel(:)`  | `INTEGER, ALLOCATABLE`      | Number of deleted (high virtual, excluded from correlation) orbitals per symmetry.                         |
| `iosh(:)`  | `INTEGER, ALLOCATABLE`      | Starting index (offset) for orbitals of a given symmetry in a globally numbered list of orbitals.          |
| `nbast`    | `INTEGER`                   | Total number of basis functions (purpose somewhat unclear from initialization, might be overall basis size). |
| `nisht`    | `INTEGER`                   | Total number of inactive (core) orbitals across all symmetries.                                            |
| `nasht`    | `INTEGER`                   | Total number of active orbitals across all symmetries.                                                     |
| `nssht`    | `INTEGER`                   | Total number of secondary (virtual) orbitals across all symmetries.                                        |
| `norbtt_b` | `INTEGER*8`                 | Total number of orbitals (read from HDF5, sum of `norb_b`).                                                |
| `nsym_b`   | `INTEGER*8`                 | Number of symmetries (read from HDF5).                                                                     |
| `norb_b(:)`| `INTEGER*8, ALLOCATABLE`    | Number of orbitals per symmetry (as read from HDF5).                                                       |
| `nfro_b(:)`| `INTEGER*8, ALLOCATABLE`    | Number of frozen orbitals per symmetry (as read from HDF5).                                                |
| `ndel_b(:)`| `INTEGER*8, ALLOCATABLE`    | Number of deleted orbitals per symmetry (as read from HDF5).                                               |
| `ecor_b`   | `REAL*8`                    | Core energy (intended to be read from HDF5, but commented out in the snippet).                             |

---

### `type_inforb_short`

This derived type appears to serve as an interface structure, particularly for receiving orbital space information from a MOLCAS environment. A public module variable `inforb_molcas` of this type holds this data.

| Member  | Type                        | Description                                                                                             |
| :------ | :-------------------------- | :------------------------------------------------------------------------------------------------------ |
| `nfro(:)`| `INTEGER, ALLOCATABLE`      | Number of frozen orbitals per symmetry.                                                                 |
| `nish(:)`| `INTEGER, ALLOCATABLE`      | Number of inactive (doubly occupied, non-frozen) orbitals per symmetry.                                 |
| `nash(:)`| `INTEGER, ALLOCATABLE`      | Number of active orbitals per symmetry.                                                                 |
| `nssh(:)`| `INTEGER, ALLOCATABLE`      | Number of secondary (virtual, non-deleted) orbitals per symmetry.                                       |
| `ndel(:)`| `INTEGER, ALLOCATABLE`      | Number of deleted orbitals per symmetry.                                                                |
| `norb(:)`| `INTEGER, ALLOCATABLE`      | Number of orbitals per symmetry (nfro + nish + nash + nssh + ndel for MOLCAS context).                    |
| `nbas(:)`| `INTEGER, ALLOCATABLE`      | Number of basis functions per symmetry.                                                                 |
| `nbast` | `INTEGER`                   | Total number of basis functions.                                                                        |
| `nbsqt` | `INTEGER`                   | Total number of basis functions squared (purpose unclear).                                              |
| `ncmo`  | `INTEGER`                   | Total number of canonical molecular orbitals.                                                           |

## Public Module Variables

### `inforb`

*   **Type:** `type_inforb`
*   **Attributes:** `SAVE`
*   **Purpose:** The primary instance of `type_inforb` that stores the definitive orbital space definitions (counts per symmetry, total counts, offsets) used by the NEVPT2 program.

### `inforb_molcas`

*   **Type:** `type_inforb_short`
*   **Attributes:** `SAVE`
*   **Purpose:** Used as a temporary holding structure for orbital space information passed from an external program interface, like MOLCAS, before it's processed and transferred into the main `inforb` variable.

## Public Subroutines

---

### `initialize_inforb`

*   **Signature:** `subroutine initialize_inforb(nsym, norb, from_molcas)`
*   **Arguments:**
    *   `nsym`: `INTEGER, INTENT(OUT)` - Returns the number of symmetries.
    *   `norb`: `INTEGER, INTENT(OUT)` - Returns the total number of orbitals.
    *   `from_molcas`: `LOGICAL, INTENT(IN)` - A flag; if `.TRUE.`, orbital information is sourced from `inforb_molcas`. If `.FALSE.`, it's read from an HDF5 file (e.g., `ijkl.h5`).
*   **Purpose:** Initializes the main `inforb` data structure.
    *   If not `from_molcas`: Reads basic symmetry and orbital counts per symmetry (`nsym_b`, `norb_b`, `nfro_b`, `ndel_b`) from an HDF5 file. It then attempts to determine the distribution of inactive, active, and secondary orbitals (`nish`, `nash`, `nssh`) by parsing a `*.RasOrb` file (noting this method can be error-prone).
    *   If `from_molcas`: Copies the orbital counts (`norb`, `nfro`, `ndel`, `nish`, `nash`, `nssh`) from the `inforb_molcas` structure (which is assumed to have been populated beforehand by `initialize_inforb_molcas` and the MOLCAS interface).
    *   Calculates `iosh` (orbital offsets per symmetry) and total orbital counts (`norb`, `inforb%nosh`).
    *   Adjusts `nish` and `nssh` by subtracting `nfro` and `ndel` respectively to ensure non-overlapping categories.

---

### `finalize_inforb`

*   **Signature:** `subroutine finalize_inforb()`
*   **Arguments:** None.
*   **Purpose:** Deallocates all allocatable arrays within the `inforb` module variable (`norb_b`, `nfro_b`, `ndel_b`, `nosh`, `nish`, `nash`, `nssh`, `nfro`, `ndel`, `iosh`).

---

### `initialize_inforb_molcas`

*   **Signature:** `subroutine initialize_inforb_molcas(nsym)`
*   **Arguments:**
    *   `nsym`: `INTEGER, INTENT(IN)` - The number of symmetries.
*   **Purpose:** Allocates the arrays within the `inforb_molcas` derived type based on the provided number of symmetries. This routine is intended to be called by an external interface (e.g., MOLCAS) which then populates the `inforb_molcas` members. Subsequently, `initialize_inforb` would be called with `from_molcas = .TRUE.`.

---

### `finalize_inforb_molcas`

*   **Signature:** `subroutine finalize_inforb_molcas()`
*   **Arguments:** None.
*   **Purpose:** Deallocates all allocatable arrays within the `inforb_molcas` module variable.

---

### `set_orbarray_pointers`

*   **Signature:** `subroutine set_orbarray_pointers(nsym, norb, ncore, nact, nvirt, itsym, nord_mn_c, nord_mn_a, nord_mn_v, nord_nev2mol, nord_mol2nev, nc, na, nv, nbe, nmo, ncmax, nvmax)`
*   **Arguments:**
    *   `nsym`: `INTEGER, INTENT(IN)` - Number of symmetries.
    *   `norb`: `INTEGER, INTENT(IN)` - Total number of orbitals.
    *   `ncore`: `INTEGER, INTENT(IN)` - Total number of core (inactive) orbitals.
    *   `nact`: `INTEGER, INTENT(IN)` - Total number of active orbitals.
    *   `nvirt`: `INTEGER, INTENT(IN)` - Total number of virtual (secondary) orbitals.
    *   `itsym(2*norb+1)`: `INTEGER, INTENT(IN)` - Array containing the symmetry label for each orbital (and possibly spin-orbitals).
    *   `nord_mn_c(ncore,nsym)`: `INTEGER, INTENT(OUT)` - Stores global indices of core orbitals, per symmetry.
    *   `nord_mn_a(nact,nsym)`: `INTEGER, INTENT(OUT)` - Stores global indices of active orbitals, per symmetry.
    *   `nord_mn_v(nvirt,nsym)`: `INTEGER, INTENT(OUT)` - Stores global indices of virtual orbitals, per symmetry.
    *   `nord_nev2mol(norb)`: `INTEGER, INTENT(OUT)` - Mapping from NEVPT2 internal orbital ordering to external (MOLCAS) ordering.
    *   `nord_mol2nev(norb)`: `INTEGER, INTENT(OUT)` - Mapping from external (MOLCAS) orbital ordering to NEVPT2 internal ordering.
    *   `nc(nsym)`: `INTEGER, INTENT(OUT)` - Number of core orbitals per symmetry.
    *   `na(nsym)`: `INTEGER, INTENT(OUT)` - Number of active orbitals per symmetry.
    *   `nv(nsym)`: `INTEGER, INTENT(OUT)` - Number of virtual orbitals per symmetry.
    *   `nbe(nsym)`: `INTEGER, INTENT(OUT)` - Base (starting) index for orbitals of a given symmetry in the NEVPT2 internal ordering.
    *   `nmo(nsym)`: `INTEGER, INTENT(OUT)` - Total number of molecular orbitals per symmetry (`nc(isym)+na(isym)+nv(isym)`).
    *   `ncmax`: `INTEGER, INTENT(OUT)` - Maximum number of core orbitals in any single symmetry.
    *   `nvmax`: `INTEGER, INTENT(OUT)` - Maximum number of virtual orbitals in any single symmetry.
*   **Purpose:** This subroutine is critical for establishing the mapping and distribution of orbitals according to their type (core, active, virtual) and symmetry. It populates various arrays that allow other parts of the program to easily access orbitals based on these classifications and to translate between the program's internal ordering (which is typically packed by symmetry and then by type) and the original orbital numbering from the source of MOs (e.g., MOLCAS).

---

**Note on Getter/Setter Functions from Prompt:**

The functions `get_orb_e`, `get_orb_sym`, `get_orb_type`, `set_orb_e` mentioned in the user prompt are **not** defined in this specific module (`info_orbital_space.F90`).
*   Orbital energies are managed in the `info_state_energy` module or handled as part of effective Fock matrix elements elsewhere.
*   Orbital symmetries are passed into `set_orbarray_pointers` via the `itsym` array, which is presumably populated from an external source (like an SCF or CASSCF calculation).
*   Orbital "type" (core, active, virtual) is implicitly defined by ranges (`ncore`, `nact`, `nvirt`) and the ordering established by `set_orbarray_pointers`. There isn't a per-orbital type flag set here, but rather classification by index ranges per symmetry.
Access to the counts of orbitals per type and symmetry (e.g., `inforb%nish`, `inforb%nash`) is available through the public `inforb` module variable.
```
